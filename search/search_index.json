{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unidad 0 Tarea Obligatoria Ra\u00fal Pe\u00f1a Introducci\u00f3n En esta documentaci\u00f3n se plasmar\u00e1n todos los pasos realizados para crear un directorio en github, configurarlo de modo que podamos generar una web est\u00e1tica entorno al directorio y posteriormente demostrar nuestro conocimiento de docker levantando un contenedor nginx en el que podamos acceder a nuestra web est\u00e1tica. \u00cdndice Creaci\u00f3n repositorio Configuraci\u00f3n para la web est\u00e1tica Creaci\u00f3n y puesta en marcha Nginx Conclusiones","title":"Home"},{"location":"#unidad-0-tarea-obligatoria-raul-pena","text":"","title":"Unidad 0 Tarea Obligatoria Ra\u00fal Pe\u00f1a"},{"location":"#introduccion","text":"En esta documentaci\u00f3n se plasmar\u00e1n todos los pasos realizados para crear un directorio en github, configurarlo de modo que podamos generar una web est\u00e1tica entorno al directorio y posteriormente demostrar nuestro conocimiento de docker levantando un contenedor nginx en el que podamos acceder a nuestra web est\u00e1tica.","title":"Introducci\u00f3n"},{"location":"#indice","text":"Creaci\u00f3n repositorio Configuraci\u00f3n para la web est\u00e1tica Creaci\u00f3n y puesta en marcha Nginx Conclusiones","title":"\u00cdndice"},{"location":"conclusiones/","text":"Conclusiones de la tarea Mediante el desarrollo y realizaci\u00f3n de esta actividad hemos podido integrar varios conceptos claves de esta unidad. Integraci\u00f3n del flujo de trabajo moderno La pr\u00e1ctica ha permitido comprender c\u00f3mo integrar distintas herramientas fundamentales en el desarrollo actual: GitHub para el control de versiones, GitHub Pages para el despliegue de contenido est\u00e1tico y Docker para la contenedorizaci\u00f3n. Esto demuestra c\u00f3mo un proyecto puede pasar del c\u00f3digo fuente a un entorno desplegable de forma coherente y profesional. Despliegue sencillo y automatizado con GitHub Pages Configurar el repositorio para servir una web est\u00e1tica a trav\u00e9s de GitHub Pages ha evidenciado lo sencillo que es publicar contenido directamente desde GitHub sin necesidad de infraestructura adicional. Esto facilita compartir documentaci\u00f3n, portfolios o demos de forma inmediata. Portabilidad y consistencia mediante Docker La creaci\u00f3n del contenedor Docker ha mostrado la importancia de la portabilidad en entornos de despliegue. Al encapsular la web est\u00e1tica dentro de un contenedor, se garantiza que pueda ejecutarse de forma id\u00e9ntica en cualquier sistema, evitando problemas derivados de diferencias entre entornos. Comprensi\u00f3n del ciclo completo de desarrollo y despliegue Gracias a la combinaci\u00f3n de GitHub y Docker, se ha trabajado un flujo completo: creaci\u00f3n del c\u00f3digo, versionado, publicaci\u00f3n en un entorno remoto y puesta en marcha mediante un contenedor. Esto refleja pr\u00e1cticas reales de DevOps y mejora la comprensi\u00f3n de procesos de despliegue modernos. Mejora de habilidades t\u00e9cnicas clave A trav\u00e9s de esta tarea se han reforzado conocimientos esenciales: manejo de repositorios Git, configuraci\u00f3n de GitHub Pages, creaci\u00f3n de Dockerfiles, construcci\u00f3n de im\u00e1genes, ejecuci\u00f3n de contenedores y comprensi\u00f3n del concepto de web est\u00e1tica. Base s\u00f3lida para proyectos m\u00e1s avanzados Como es de esperar a lo largo del curso seguramente realizaremos muchas actividades y tareas en las que deberemos emplear nuevamente estas herramientas que hemos visto como GitHub y Docker, en los que hemos desarrollado cierta soltura a la hora de trabajar con ellas.","title":"Conclusiones"},{"location":"conclusiones/#conclusiones-de-la-tarea","text":"Mediante el desarrollo y realizaci\u00f3n de esta actividad hemos podido integrar varios conceptos claves de esta unidad.","title":"Conclusiones de la tarea"},{"location":"conclusiones/#integracion-del-flujo-de-trabajo-moderno","text":"La pr\u00e1ctica ha permitido comprender c\u00f3mo integrar distintas herramientas fundamentales en el desarrollo actual: GitHub para el control de versiones, GitHub Pages para el despliegue de contenido est\u00e1tico y Docker para la contenedorizaci\u00f3n. Esto demuestra c\u00f3mo un proyecto puede pasar del c\u00f3digo fuente a un entorno desplegable de forma coherente y profesional.","title":"Integraci\u00f3n del flujo de trabajo moderno"},{"location":"conclusiones/#despliegue-sencillo-y-automatizado-con-github-pages","text":"Configurar el repositorio para servir una web est\u00e1tica a trav\u00e9s de GitHub Pages ha evidenciado lo sencillo que es publicar contenido directamente desde GitHub sin necesidad de infraestructura adicional. Esto facilita compartir documentaci\u00f3n, portfolios o demos de forma inmediata.","title":"Despliegue sencillo y automatizado con GitHub Pages"},{"location":"conclusiones/#portabilidad-y-consistencia-mediante-docker","text":"La creaci\u00f3n del contenedor Docker ha mostrado la importancia de la portabilidad en entornos de despliegue. Al encapsular la web est\u00e1tica dentro de un contenedor, se garantiza que pueda ejecutarse de forma id\u00e9ntica en cualquier sistema, evitando problemas derivados de diferencias entre entornos.","title":"Portabilidad y consistencia mediante Docker"},{"location":"conclusiones/#comprension-del-ciclo-completo-de-desarrollo-y-despliegue","text":"Gracias a la combinaci\u00f3n de GitHub y Docker, se ha trabajado un flujo completo: creaci\u00f3n del c\u00f3digo, versionado, publicaci\u00f3n en un entorno remoto y puesta en marcha mediante un contenedor. Esto refleja pr\u00e1cticas reales de DevOps y mejora la comprensi\u00f3n de procesos de despliegue modernos.","title":"Comprensi\u00f3n del ciclo completo de desarrollo y despliegue"},{"location":"conclusiones/#mejora-de-habilidades-tecnicas-clave","text":"A trav\u00e9s de esta tarea se han reforzado conocimientos esenciales: manejo de repositorios Git, configuraci\u00f3n de GitHub Pages, creaci\u00f3n de Dockerfiles, construcci\u00f3n de im\u00e1genes, ejecuci\u00f3n de contenedores y comprensi\u00f3n del concepto de web est\u00e1tica.","title":"Mejora de habilidades t\u00e9cnicas clave"},{"location":"conclusiones/#base-solida-para-proyectos-mas-avanzados","text":"Como es de esperar a lo largo del curso seguramente realizaremos muchas actividades y tareas en las que deberemos emplear nuevamente estas herramientas que hemos visto como GitHub y Docker, en los que hemos desarrollado cierta soltura a la hora de trabajar con ellas.","title":"Base s\u00f3lida para proyectos m\u00e1s avanzados"},{"location":"docker/","text":"Docker nginx con la web est\u00e1tica En este \u00faltimo apartado vamos a crear un contenedor de docker. La idea es que el contenedor que estar\u00e1 basado en la imagen de nginx muestre la web est\u00e1tica creada a partir de nuestro repositorio de git. Creaci\u00f3n del contenedor Antes de crear el contenedor tenemos que tener en cuenta que los archivos de la web est\u00e1tica se encuentran en la rama gh-pages de nuestro repositorio, informaci\u00f3n muy \u00fatil que nos ayudar\u00e1 a la hora de crear el volumen del contenedor con Bind-mount . Este contenedor que vamos a crear debe tener las siguientes caracter\u00edsticas: El nombre del contenedor ser\u00e1 PPSUnidad0-Tarea-Minombre. Debemos redirigir el puerto que muestra la web nginx al puerto 8085 de nuestra m\u00e1quina. Usaremos un bind-mount para unir la carpeta de nuestro repositorio. Una vez tenemos esto claro debemos elegir un m\u00e9todo para crear el contenedor, en mi caso voy a levantarlo con un docker-compose.yml, el cual tiene la siguiente estructura: En este docker composo se muestra lo primero la version, la cual hemos definido como la 3.9 y despu\u00e9s debemos definir los servicios del contenedor: El contenedor desplegar\u00e1 un servicio nginx basado en la imagen nginx:latest, la \u00faltima versi\u00f3n. Definimos el nombre del contenedor. Especifcamos el puerto al cual vamos a redirigir el servicio en nuestra m\u00e1quina anfitriona. Definimos el volumen del contenedor. En este caso ser\u00e1 un bind-mount que unir\u00e1 la carpeta gh-pages del repositorio git con el directorio donde nginx guarda los archivos de la web. Por \u00faltimo hemos especificado la opci\u00f3n para que se reinicie cuando se produzca un error. IMPORTANTE : hay que tener en cuenta que puede que no exista el directorio ../gh-pages o este vac\u00edo para ello debemos situarnos en la rama gh-pages y crear el directorio adem\u00e1s de copiar los archivos de la rama en este directorio con los siguientes comandos: mkdir -p ../gh-pages sudo cp -R * ../gh-pages Con estos comandos abremos copiado la web est\u00e1tica en la carpeta hemos especificado el bind-mount de nuestro contenedor de docker. Muestra del contenedor Una vez tengamos nuestro docker-compose.yml creado, en mi caso esta en la rama main de mi repositorio de git, nos dirigiremos a dicha rama y ejecutamos el comando docker compose up -d para levantar el contenedor como demonio. Con el contenedor en ejecuci\u00f3n podemos acceder a la direcci\u00f3n 127.0.0.1:8085 donde hemos redirigido la p\u00e1gina nginx en nuestra m\u00e1quina local y se nos mostrar\u00e1 la p\u00e1gina de github.io: Y ya tendr\u00edamos el contenedor creado y en ejecuci\u00f3n, podemos ver el estado de este gracias al comando docker inspect , como se muestra en la siguiente imagen: Para parar el contenedor simplemente tenemos que ejecutar el comando docker compose down .","title":"Docker"},{"location":"docker/#docker-nginx-con-la-web-estatica","text":"En este \u00faltimo apartado vamos a crear un contenedor de docker. La idea es que el contenedor que estar\u00e1 basado en la imagen de nginx muestre la web est\u00e1tica creada a partir de nuestro repositorio de git.","title":"Docker nginx con la web est\u00e1tica"},{"location":"docker/#creacion-del-contenedor","text":"Antes de crear el contenedor tenemos que tener en cuenta que los archivos de la web est\u00e1tica se encuentran en la rama gh-pages de nuestro repositorio, informaci\u00f3n muy \u00fatil que nos ayudar\u00e1 a la hora de crear el volumen del contenedor con Bind-mount . Este contenedor que vamos a crear debe tener las siguientes caracter\u00edsticas: El nombre del contenedor ser\u00e1 PPSUnidad0-Tarea-Minombre. Debemos redirigir el puerto que muestra la web nginx al puerto 8085 de nuestra m\u00e1quina. Usaremos un bind-mount para unir la carpeta de nuestro repositorio. Una vez tenemos esto claro debemos elegir un m\u00e9todo para crear el contenedor, en mi caso voy a levantarlo con un docker-compose.yml, el cual tiene la siguiente estructura: En este docker composo se muestra lo primero la version, la cual hemos definido como la 3.9 y despu\u00e9s debemos definir los servicios del contenedor: El contenedor desplegar\u00e1 un servicio nginx basado en la imagen nginx:latest, la \u00faltima versi\u00f3n. Definimos el nombre del contenedor. Especifcamos el puerto al cual vamos a redirigir el servicio en nuestra m\u00e1quina anfitriona. Definimos el volumen del contenedor. En este caso ser\u00e1 un bind-mount que unir\u00e1 la carpeta gh-pages del repositorio git con el directorio donde nginx guarda los archivos de la web. Por \u00faltimo hemos especificado la opci\u00f3n para que se reinicie cuando se produzca un error. IMPORTANTE : hay que tener en cuenta que puede que no exista el directorio ../gh-pages o este vac\u00edo para ello debemos situarnos en la rama gh-pages y crear el directorio adem\u00e1s de copiar los archivos de la rama en este directorio con los siguientes comandos: mkdir -p ../gh-pages sudo cp -R * ../gh-pages Con estos comandos abremos copiado la web est\u00e1tica en la carpeta hemos especificado el bind-mount de nuestro contenedor de docker.","title":"Creaci\u00f3n del contenedor"},{"location":"docker/#muestra-del-contenedor","text":"Una vez tengamos nuestro docker-compose.yml creado, en mi caso esta en la rama main de mi repositorio de git, nos dirigiremos a dicha rama y ejecutamos el comando docker compose up -d para levantar el contenedor como demonio. Con el contenedor en ejecuci\u00f3n podemos acceder a la direcci\u00f3n 127.0.0.1:8085 donde hemos redirigido la p\u00e1gina nginx en nuestra m\u00e1quina local y se nos mostrar\u00e1 la p\u00e1gina de github.io: Y ya tendr\u00edamos el contenedor creado y en ejecuci\u00f3n, podemos ver el estado de este gracias al comando docker inspect , como se muestra en la siguiente imagen: Para parar el contenedor simplemente tenemos que ejecutar el comando docker compose down .","title":"Muestra del contenedor"},{"location":"git/","text":"Creaci\u00f3n repositorio de Github En este apartado se mostrar\u00e1 como crear un repositorio de github y modificaremos su infraestructura. Primero creamos el repositorio desde github como se muestra en la imagen: Una vez creado el repositorio lo vamos a clonar con git clone mediante ssh para tenerlo en nuestro equipo personal. Para crear la infraestructura del proyecto hemos clonado un repositorio de una actividad anterior muy parecida a esta y hemos borrado y a\u00f1adido algunos archivos seg\u00fan quer\u00edamos presentar el repositorio. Una vez realizado los cambios hemos a\u00f1adido los archivos nuevos con los comandos git add . y git commit , en la siguiente imagen se muestra mejor: Luego para a\u00f1adirlo a el repositorio original en github hemos utilizado el comando git push origin main .","title":"Git"},{"location":"git/#creacion-repositorio-de-github","text":"En este apartado se mostrar\u00e1 como crear un repositorio de github y modificaremos su infraestructura. Primero creamos el repositorio desde github como se muestra en la imagen: Una vez creado el repositorio lo vamos a clonar con git clone mediante ssh para tenerlo en nuestro equipo personal. Para crear la infraestructura del proyecto hemos clonado un repositorio de una actividad anterior muy parecida a esta y hemos borrado y a\u00f1adido algunos archivos seg\u00fan quer\u00edamos presentar el repositorio. Una vez realizado los cambios hemos a\u00f1adido los archivos nuevos con los comandos git add . y git commit , en la siguiente imagen se muestra mejor: Luego para a\u00f1adirlo a el repositorio original en github hemos utilizado el comando git push origin main .","title":"Creaci\u00f3n repositorio de Github"},{"location":"gitActions/","text":"Creaci\u00f3n de la web est\u00e1tica En estos apartados se mostrar\u00e1 como hemos creado la infraestructura de la web est\u00e1tica basada en nuestro repositorio de git, as\u00ed como los pasos para mostrar dicha web. Configuraci\u00f3n MkDocs Para configurar el mkdocs.yml, el cual tenemos creado gracias a clonar el repositorio de otra actividad, hemos accedido a este archivo el cual se muestra tal que as\u00ed: En nuestro mkdocs hemos configurado lo siguiente: Site_name: esta es una variable u opci\u00f3n que define el nombre de la p\u00e1gina, el que se muestra en la barra de pesta\u00f1as abiertas. nav: este es el navegador de nuestra web est\u00e1tica, el cual es una lista con las diferentes secciones de la web, cada secci\u00f3n se define con un gui\u00f3n el nombre de la secci\u00f3n y seguido enlazamos con el archivo markdown que muestra el contenido de esa secci\u00f3n. doc_dir: esta variable es en la que especificaremos la carpeta o el directorio donde se encuentran los archivos md que formar\u00e1n la web est\u00e1tica. Mostrar la web est\u00e1tica Una vez tenemos definido nuestro archivo mkdocs, para mostrar nuestra web debemos realizar la siguiente configuraci\u00f3n: Dirigirnos a las settings del repositorio. En el apartado Pages seleccionamos la fuente Deploy from a branch . En el apartado branch seleccionamos la rama que contiene los archivos de la web, en nuestro caso gh-pages. Guardamos los cambios y al cabo de unos minutos nos aparecer\u00e1 la secci\u00f3n Deployments en nuestro repositorio desde la cual podemos acceder a la web. En la siguiente imagen se muestra mejor la configuraci\u00f3n a realizar:","title":"GitActions"},{"location":"gitActions/#creacion-de-la-web-estatica","text":"En estos apartados se mostrar\u00e1 como hemos creado la infraestructura de la web est\u00e1tica basada en nuestro repositorio de git, as\u00ed como los pasos para mostrar dicha web.","title":"Creaci\u00f3n de la web est\u00e1tica"},{"location":"gitActions/#configuracion-mkdocs","text":"Para configurar el mkdocs.yml, el cual tenemos creado gracias a clonar el repositorio de otra actividad, hemos accedido a este archivo el cual se muestra tal que as\u00ed: En nuestro mkdocs hemos configurado lo siguiente: Site_name: esta es una variable u opci\u00f3n que define el nombre de la p\u00e1gina, el que se muestra en la barra de pesta\u00f1as abiertas. nav: este es el navegador de nuestra web est\u00e1tica, el cual es una lista con las diferentes secciones de la web, cada secci\u00f3n se define con un gui\u00f3n el nombre de la secci\u00f3n y seguido enlazamos con el archivo markdown que muestra el contenido de esa secci\u00f3n. doc_dir: esta variable es en la que especificaremos la carpeta o el directorio donde se encuentran los archivos md que formar\u00e1n la web est\u00e1tica.","title":"Configuraci\u00f3n MkDocs"},{"location":"gitActions/#mostrar-la-web-estatica","text":"Una vez tenemos definido nuestro archivo mkdocs, para mostrar nuestra web debemos realizar la siguiente configuraci\u00f3n: Dirigirnos a las settings del repositorio. En el apartado Pages seleccionamos la fuente Deploy from a branch . En el apartado branch seleccionamos la rama que contiene los archivos de la web, en nuestro caso gh-pages. Guardamos los cambios y al cabo de unos minutos nos aparecer\u00e1 la secci\u00f3n Deployments en nuestro repositorio desde la cual podemos acceder a la web. En la siguiente imagen se muestra mejor la configuraci\u00f3n a realizar:","title":"Mostrar la web est\u00e1tica"}]}